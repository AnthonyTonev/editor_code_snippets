{
   "title":"hash_table",
   "description":"",
   "code":"class HashTable{\n      #maxCoef;\n      #minCoef; \n      #count=0;\n      #elements;\n      constructor(size=8,mincoef=0.25,maxcoef=0.5){\n          this.#elements  = Array.from({length: size}).fill([]);\n          this.#minCoef = mincoef;   \n          this.#maxCoef = maxcoef;\n       }\n      //оразмеряване О(n)\n      #resizeBounds = function(size){\n         const flattenArray = this.#elements.flat(1);\n         this.#elements = Array.from({length: Math.floor(size)}).fill([]);\n         //тъй като стойностите са нечетните индекси итерираме само половината но достъпваме и 2-та\n         for(let i=0; i<flattenArray.length;i+=2){\n         this.#insert(flattenArray[i], flattenArray[i+1])\n         }\n      }\n      //кога да оразмерява и как (в каква посока и колко)      \n      #updateElementsBounds = function(){\n          if( this.#count / this.#elements.length >= this.#maxCoef) {\n          this.#count = 0;\n          this.#resizeBounds(this.#elements.length * 2);\n          }\n          else if ( this.#count / this.#elements.length < this.#minCoef) {\n          this.#count = 0;\n          this.#resizeBounds(this.#elements.length/2)\n          }\n        }\n        //сравнително ок хеш алгоритъм копиран от Stack Overflow O(n), но само за малък стринг       \n        #getHashCode = (string)=>{\n        let hash = 0;\n        if(!string) return hash;\n        for (let i = 0; i < string.length; i++) {\n            const char = string.charCodeAt(i);\n            hash = ((hash<<5)-hash)+char;\n            hash = hash & hash; \n        }\n        return (hash < 0 ? hash*-1+1: hash)\n            }  \n          //ковертиране на хаш в индекс      \n          #convertHashToIndex = function(hash){\n                return hash % this.#elements.length;\n            };  \n    \n          //скрит метод за добавяне на елемент О(1)     \n          #insert = function(key,value){\n              this.#count++;\n              const index = this.#convertHashToIndex(this.#getHashCode(key));\n              const selection = this.#elements[index];\n              if (selection.length === 0) {\n                  this.#elements[index] = [key,value];\n              } else {\n                  const depthIndex = this.#findDepthIndexByKey(index,key); \n                  if(selection[depthIndex]===key){\n                     selection[depthIndex+1] = value;          \n                  }else{\n                    selection.push(key,value);\n                  }\n              }\n          }\n         //публичен метод за добавяне на елемент О(1)\n         set(key,value=null){\n             this.#insert(key,value)\n             if(this.#count>this.#elements.length/2){\n               this.#updateElementsBounds();\n             }\n            }\n      \n          //достъпване на елемент  О(1) ~ О(n) рядко в зависимост от дълбочината (средно 4 елемент) \n          get(key){\n              const index = this.#convertHashToIndex(this.#getHashCode(key));\n              const selection =  this.#elements[index];\n              if(selection.length === 2 && selection[0]===key) return selection[1];\n              else if(selection.length>2){\n                const depthIndex = this.#findDepthIndexByKey(index,key);\n                return selection[depthIndex+1]; \n              }\n        return null;       \n          }\n          //премахване на елемент О(1)\n          delete(key){\n            let value = null;\n            const index = this.#convertHashToIndex(this.#getHashCode(key));\n            const selection = this.#elements[index];\n            const len = selection.length;\n            if(len === 2){\n             value = selection[1];\n             selection.length = 0; \n            }else if(len > 2){\n             const bottom = [selection[len-2],selection[len-1]];\n             if(bottom[0]===key){\n               value = selection[len-1];\n               selection.length-=2;\n             }else{\n               //O(n) където n e дълбочината на клетката\n             const keyIndex = this.#findDepthIndexByKey(index,key);\n             //жунглиране на индексите - слагам в края и намаляме дължината на масива O(?)\n             value = selection[keyIndex+1]\n             selection[keyIndex]=bottom[0];\n             selection[keyIndex+1]=bottom[1];\n             selection.length-=2;\n             }\n            }\n             this.#count--;\n             if(this.#count<this.#elements.length){\n               this.#updateElementsBounds();\n            }\n             return value;\n           }\n        \n          get count(){\n           return this.#count; \n          }\n          //ползва се на 2 места\n      #findDepthIndexByKey = function(index,key){\n         const selection = this.#elements[index];\n         //тъй като стойностите са нечетните индекси итерираме само половината \n         for(let i =0; i<selection.length;i+=2){\n                  if(selection[i] === key) {\n                    return i;\n                   }\n                }\n         }\n          //Взимане на стойности O(n)\n          values(){\n            const elements = this.#elements.flat(1);\n            const values = [];\n           //тъй като стойностите са нечетните индекси итерираме само половината\n            for(let i = 1; i<=elements.length;i+=2){\n              values.push(elements[i]);\n            }\n           return values;\n          }\n       //Взимане на ключове O(n)\n          keys(){\n            const elements = this.#elements.flat(1);\n            const keys = [];\n           //тъй като стойностите са нечетните индекси итерираме само половината\n            for(let i = 0; i<elements.length;i+=2){\n              keys.push(elements[i]);\n            }\n           return keys;\n          }\n      //Взимане на [ключове, стойности] O(n)\n          entries(){\n            const elements = this.#elements.flat(1);\n            const entries = [];\n           //тъй като стойностите са нечетните индекси итерираме само половината\n            for(let i = 0; i<elements.length;i+=2){\n              entries.push([elements[i],elements[i+1]]);\n            }\n           return entries;\n          }\n      }"
}





