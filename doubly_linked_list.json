
 {
  "title": "binary_search",
  "description": "",
  "code":"\n  class DoublyLinkedList {\n    /** @type {LinkedListNode} */\n    #head = null;\n    /** @type {LinkedListNode} */\n    #tail = null;\n    #count = 0;\n\n    get count() {\n        return this.#count;\n    }\n\n    get head() {\n        return this.#head;\n    }\n\n    get tail() {\n        return this.#tail;\n    }\n\n    addFirst(value) {\n        if (this.#head === null) {\n            this.#head = new LinkedListNode(value);\n            this.#tail = this.#head;\n        }\n        else {\n            this.insertBeforeHead(value);\n        }\n\n        this.#count++;\n    }\n\n    addLast(value) {\n        if (this.#tail === null) {\n            this.#tail = new LinkedListNode(value);\n            this.#head = this.#tail;\n        }\n        else {\n            this.insertAfterTail(value);\n        }\n\n        this.#count++;\n    }\n\n    insertAfter(node, value) {\n        if (!node) {\n            throw new Error(\"Cant insert after null/undefined node\");\n        }\n\n        if (node === this.#tail) {\n            this.insertAfterTail(value);\n        }\n        else {\n            const newNode = new LinkedListNode(value);\n            newNode.prev = node;\n            newNode.next = node.next;\n            node.next.prev = newNode;\n            node.next = newNode;\n        }\n\n        this.#count++;\n    }\n\n    insertBefore(node, value) {\n        if (!node) {\n            throw new Error(\"Cant insert before null/undefined node\");\n        }\n\n        if (node === this.#head) {\n            this.insertBeforeHead(value);\n        }\n        else {\n            const newNode = new LinkedListNode(value);\n            newNode.next = node;\n            newNode.prev = node.prev;\n            node.prev.next = newNode;\n            node.prev = newNode;\n        }\n\n        this.#count++;\n    }\n\n    removeFirst() {\n        if (this.#head === null) {\n            throw new Error(\"List is empty\");\n        }\n\n        const val = this.#head.value\n        this.#head = this.#head.next;\n\n        if (this.#head === null) {\n            this.#tail = null;\n        }\n        else {\n            this.#head.prev = null;\n        }\n\n        this.#count--;\n\n        return val;\n    }\n\n\n    removeLast() {\n        if (this.#tail === null) {\n            throw new Error(\"List is empty\");\n        }\n\n        const val = this.#tail.value;\n        this.#tail = this.#tail.prev;\n\n        if (this.#tail === null) {\n            this.#head = null;\n        }\n        else {\n            this.#tail.next = null;\n        }\n\n        this.#count--;\n\n        return val;\n    }\n\n    find(value) {\n        let current = this.#head;\n        while (current !== null) {\n            if (current.value === value) {\n                return current;\n            }\n            current = current.next;\n        }\n\n        return null;\n    }\n\n    values() {\n        const values = [];\n        let current = this.#head;\n        while (current !== null) {\n            values.push(current.value);\n            current = current.next;\n        }\n\n        return values;\n    }\n\n    insertBeforeHead(value) {\n        const newNode = new LinkedListNode(value);\n\n        newNode.next = this.#head;\n        this.#head.prev = newNode;\n        this.#head = newNode;\n    }\n\n    insertAfterTail(value) {\n        const newNode = new LinkedListNode(value);\n\n        newNode.prev = this.#tail;\n        this.#tail.next = newNode;\n        this.#tail = newNode;\n    }\n}\n\n\n"
 }

